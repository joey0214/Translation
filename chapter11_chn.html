<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Chapter 11 走向3D：PDB模块 &mdash; python_chn_ch11 .1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="python_chn_ch11 .1 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="index.html">python_chn_ch11 .1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="chapter-11-3d-pdb">
<h1>Chapter 11  走向3D：PDB模块<a class="headerlink" href="#chapter-11-3d-pdb" title="Permalink to this headline">¶</a></h1>
<p>Bio.PDB是Biopython中处理生物大分子晶体结构的模块。除了别的类之外，Bio.PDB包含PDBParser类，此类能够产生一个Structure对象，以一种较方便的方式获取文件中的原子数据。在处理PDB文件头包含的信息的时候有一定的局限性。</p>
<div class="section" id="id1">
<h2>11.1  结构文件的读与写<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<div class="section" id="pdb">
<h3>11.1.1  PDB文件的读取<a class="headerlink" href="#pdb" title="Permalink to this headline">¶</a></h3>
<p>首先，我们创建一个 <tt class="docutils literal"><span class="pre">PDBParser</span></tt> 对象：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.PDBParser</span> <span class="kn">import</span> <span class="n">PDBParser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PDBParser</span><span class="p">(</span><span class="n">PERMISSIVE</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">PERMISSIV</span></tt> 标签表示一些和PDB文件相关的问题(见 <a class="reference external" href="#problem%20structures">11.7.1</a> )会被忽略，注意某些原子和/或残基会丢失。如果这个标签没有产生 <tt class="docutils literal"><span class="pre">PDBConstructionException</span></tt> ，则会在解析器运行期间有问题被检测到的时候生成。</p>
<p>Structure对象由 <tt class="docutils literal"><span class="pre">PDBParser</span></tt> 解析PDB文件产生（在此例子中，PDB文件为&#8217;pdb1fat.ent&#8217;，&#8216;1fat&#8217;是用户的定义的结构名字）:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">structure_id</span> <span class="o">=</span> <span class="s">&quot;1fat&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="s">&quot;pdb1fat.ent&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="n">structure_id</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>你可以通过PDBParser的 <tt class="docutils literal"><span class="pre">get_header</span></tt> 和 <tt class="docutils literal"><span class="pre">get_trailer</span></tt> 方法来提取PDB文件中的文件头和文件尾（简单字符串的列表）。然而许多PDB文件包含不完整或错误信息的文件头。许多错误在mmCIF格式文件得到修正。* 因此，如果你对文件头的信息感兴趣，可以用下面即将讲到的 <tt class="docutils literal"><span class="pre">MMCIF2Dict</span></tt> 来提取信息，而不是直接处理PDB文件文件头。*</p>
<p>让我们回到解析PDB文件头。结构对象有个属性叫 <tt class="docutils literal"><span class="pre">header</span></tt> ，这是一个Python字典将文件头的记录与他们的值关联起来。</p>
<p>例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">resolution</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s">&#39;resolution&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">keywords</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s">&#39;keywords&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>在这个字典中可用的键有 <tt class="docutils literal"><span class="pre">name</span></tt> 、 <tt class="docutils literal"><span class="pre">head</span></tt> 、 <tt class="docutils literal"><span class="pre">deposition_date</span></tt> 、 <tt class="docutils literal"><span class="pre">release_date</span></tt> 、 <tt class="docutils literal"><span class="pre">structure_method</span></tt> 、 <tt class="docutils literal"><span class="pre">resolution</span></tt> 、 <tt class="docutils literal"><span class="pre">structure_reference</span></tt> （这关联到一个参考文献的列表）、 <tt class="docutils literal"><span class="pre">journal_reference</span></tt> 、 <tt class="docutils literal"><span class="pre">author</span></tt> 、和 <tt class="docutils literal"><span class="pre">compound</span></tt> （关联一个包含各种晶体成分的各种信息）。
The available keys are <tt class="docutils literal"><span class="pre">name</span></tt>, <tt class="docutils literal"><span class="pre">head</span></tt>, <tt class="docutils literal"><span class="pre">deposition_date</span></tt>,
<tt class="docutils literal"><span class="pre">release_date</span></tt>, <tt class="docutils literal"><span class="pre">structure_method</span></tt>, <tt class="docutils literal"><span class="pre">resolution</span></tt>,
<tt class="docutils literal"><span class="pre">structure_reference</span></tt> (which maps to a list of references),
<tt class="docutils literal"><span class="pre">journal_reference</span></tt>, <tt class="docutils literal"><span class="pre">author</span></tt>, and <tt class="docutils literal"><span class="pre">compound</span></tt> (which maps to a
dictionary with various information about the crystallized compound).</p>
<p>这个字典也能在没有创建 <tt class="docutils literal"><span class="pre">Structure</span></tt> 对象的时候被创建，比如直接从PDB文件创建:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">header_dict</span> <span class="o">=</span> <span class="n">parse_pdb_header</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="mmcif">
<h3>11.1.2  读取mmCIF文件<a class="headerlink" href="#mmcif" title="Permalink to this headline">¶</a></h3>
<p>与PDB文件类似的也是先创建一个 <tt class="docutils literal"><span class="pre">MMCIFParser</span></tt> 对象：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.MMCIFParser</span> <span class="kn">import</span> <span class="n">MMCIFParser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">MMCIFParser</span><span class="p">()</span>
</pre></div>
</div>
<p>然后用这个解析器从mmCIF文件闯将创建一个结构对象：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="s">&#39;1fat&#39;</span><span class="p">,</span> <span class="s">&#39;1fat.cif&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>为了获得最少次数访问mmCIF文件，可以用 <tt class="docutils literal"><span class="pre">MMCIF2Dict</span></tt> 类类创建一个Python字典来储存所有mmCIF文件中各种标签和他们对应的值。如果有多个值（ <tt class="docutils literal"><span class="pre">_atom_site.Cartn_y</span></tt> 标签储存的是所有原子的y坐标的坐标值），这个标签会与一个值的列表关联。如下所示从mmCIF文件创建字典：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.MMCIF2Dict</span> <span class="kn">import</span> <span class="n">MMCIF2Dict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mmcif_dict</span> <span class="o">=</span> <span class="n">MMCIF2Dict</span><span class="p">(</span><span class="s">&#39;1FAT.cif&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>例：从mmCIF文件获取溶剂成分:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span> <span class="o">=</span> <span class="n">mmcif_dict</span><span class="p">[</span><span class="s">&#39;_exptl_crystal.density_percent_sol&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>例：获取所有包含所有原子y坐标的列表:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">y_list</span> <span class="o">=</span> <span class="n">mmcif_dict</span><span class="p">[</span><span class="s">&#39;_atom_site.Cartn_y&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="pdb-xml">
<h3>11.1.3  读取PDB XML格式的文件<a class="headerlink" href="#pdb-xml" title="Permalink to this headline">¶</a></h3>
<p>这部分暂时还未支持，正在开发中。如果你需要的话联系Biopython开发人员( <a class="reference external" href="mailto:biopython-dev&#37;&#52;&#48;biopython&#46;org">biopython-dev<span>&#64;</span>biopython<span>&#46;</span>org</a> )。</p>
</div>
<div class="section" id="id2">
<h3>11.1.4  写PDB文件<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>用类PDBIO可以实现PDB文件输出，也能很方便的输出结构的某个特定部分。</p>
<p>例子：保存结构：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">io</span> <span class="o">=</span> <span class="n">PDBIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">set_structure</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s">&#39;out.pdb&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果你想输出结构的一部分，可以用 <cite>Select</cite> 类（也是在 <tt class="docutils literal"><span class="pre">PDBIO</span></tt> 中）来实现。 <cite>Select</cite> 有如下四种方法：</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">accept_model(model)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">accept_chain(chain)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">accept_residue(residue)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">accept_atom(atom)</span></tt></li>
</ul>
<p>在默认情况下，每种方法的返回值都为1（表示model/chain/residue/atom被包含在输出结果中）。通过子类 <tt class="docutils literal"><span class="pre">Select</span></tt> 和返回值0你可以排除结构域、链等。也许比较麻烦笨重，但是还是很强大的。接下来的代码将只输出甘氨酸残基：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">GlySelect</span><span class="p">(</span><span class="n">Select</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">accept_residue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">residue</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span><span class="o">==</span><span class="s">&#39;GLY&#39;</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">return</span> <span class="bp">True</span>
<span class="gp">... </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">return</span> <span class="bp">False</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span> <span class="o">=</span> <span class="n">PDBIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">set_structure</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s">&#39;gly_only.pdb&#39;</span><span class="p">,</span> <span class="n">GlySelect</span><span class="p">())</span>
</pre></div>
</div>
<p>如果这部分对你来说太复杂， <tt class="docutils literal"><span class="pre">Dice</span></tt> 模块有一个很方便的函数 <tt class="docutils literal"><span class="pre">extract</span></tt> ，它可以输出一条链的起始和终止氨基酸残基之间的所有氨基酸残基。</p>
</div>
</div>
<div class="section" id="id3">
<h2>11.2  结构表示方法<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>一个 <tt class="docutils literal"><span class="pre">Structure</span></tt> 对象的整体布局由称为SMCRA（Structure结构/Model域/Chain链/Residue残基/Atom原子）：</dt>
<dd><ul class="first last simple">
<li>结构有域组成</li>
<li>域由多条链组成</li>
<li>链由残基组成</li>
<li>多个原子构成残基</li>
</ul>
</dd>
</dl>
<p>这是很多结构生物学家/生物信息学家看待结构的方法，也是一种简单并有效的途径处理结构。额外的信息在需要的时候加载。一个 <tt class="docutils literal"><span class="pre">Structure</span></tt> 对象的UML图如下图所示 <a class="reference external" href="#fig:smcra">11.1</a> 。这样的数据结构不是必须合适这样一个结构的生物大分子内容的展示，但对于描述结构的文件（最典型的就是PDB或MMCIF文件了）必然是个很好的途径来展示数据。如果这样层次结构不能描述结构文件的内容，那么很确定的是这个文件有错误或至少描述结构不够明确。一旦SMCRA数据结构不能产生，有理由怀疑这个问题。解析PDB文件时能够检测到这样类似的问题。我们将在这节给出一些例子 <a class="reference external" href="#problem%20structures">11.7.1</a> 。</p>
<blockquote>
<div><a href="#id36"><span class="problematic" id="id37">|image3|</span></a>
+&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;+
| 图11.1：用来展示生物大分子结构的 <tt class="docutils literal"><span class="pre">Structure</span></tt> 类的SMCRA体系的UML图。带方块的实线表示集合，带箭头的实线表示涉及，带三角形的实线表示继承，带三角形的虚线表示接口实现。    |
+&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;+</div></blockquote>
<p>结构，域，链，残基是实体类的子类。原子类仅仅（部分）实现实体接口（因为原子类没有子类）。</p>
<p>对于每个实体子类，你可以用唯一的标识符作为键来提取子类（比如，你可以用原子名称作为键从残基对象中提取原子；用链的标识符作为键从域对象中提取链）。</p>
<p>无序的原子和残基用DisorderedAtom和DisorderedResidue类来描述，二者都是DisorderedEntityWrapper基本类的子类。他们隐藏了和无序的复杂性，表现得与原子和残基对象无二。</p>
<p>一般地，一个实体子类（如原子，残基，链，域）能通过标识符键从父类中提取。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">child_entity</span> <span class="o">=</span> <span class="n">parent_entity</span><span class="p">[</span><span class="n">child_id</span><span class="p">]</span>
</pre></div>
</div>
<p>你可以从一个父Entity对象获得一个子Entity的列表。需要注意的是这个列表以一定的方式排列（例如根据在Model对象中链对象的链标识符）。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">child_list</span> <span class="o">=</span> <span class="n">parent_entity</span><span class="o">.</span><span class="n">get_list</span><span class="p">()</span>
</pre></div>
</div>
<p>你也可以从子类获得父类：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">parent_entity</span> <span class="o">=</span> <span class="n">child_entity</span><span class="o">.</span><span class="n">get_parent</span><span class="p">()</span>
</pre></div>
</div>
<p>在SMCRA的所有层次结构，你可以提取 <em>完整的ID</em> 。完整的id是一个含所有从顶层对象（结构分子）到当前对象的id字符串的元组。Residue对象的完整id可以这么获取：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">full_id</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">get_full_id</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">full_id</span>
<span class="go">(&quot;1abc&quot;, 0, &quot;A&quot;, (&quot;&quot;, 10, &quot;A&quot;))</span>
</pre></div>
</div>
<dl class="docutils">
<dt>与这些相对应的：</dt>
<dd><ul class="first last simple">
<li>id为iabc的结构</li>
<li>id为0的Model</li>
<li>id为A的链</li>
<li>id为(&#8221; &#8221;, 10, &#8220;A&#8221;)的残基</li>
</ul>
</dd>
</dl>
<p>Residue的id表示这个残基不是hetero残基（也不是水分子），因为hetero值为空；它的序列标识符为10，插入码为“A”。</p>
<p>欲获取entity的id，用 <tt class="docutils literal"><span class="pre">get_id</span></tt> 方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">entity</span><span class="o">.</span><span class="n">get_id</span><span class="p">()</span>
</pre></div>
</div>
<p>可以用 <tt class="docutils literal"><span class="pre">has_id</span></tt> 方法检查这个entity是否有给定id的子类：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">entity</span><span class="o">.</span><span class="n">has_id</span><span class="p">(</span><span class="n">entity_id</span><span class="p">)</span>
</pre></div>
</div>
<p>entity的长度等于子类的个数：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nr_children</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">entity</span><span class="p">)</span>
</pre></div>
</div>
<p>它能删除，重命名，添加，比如从父entity得到的子entity并没有进行完整性检查（有可能添加两个相同id的残基到同一条链上）。这需要Decorator类来完成包括完整性检查，但是如果你想使用最初的接口的话可以查看源代码（Entity.py）。</p>
<div class="section" id="id4">
<h3>11.2.1  结构<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>结构对象是成此结构中最高的一层。它的id是用户指定的字符串。结构包含一系列子结构域。大部分晶体结构（但不是全部）含有一个结构域，但是NMR结构经常含有多个结构域。晶体结构中大部分子的无序状态也能导致多个结构域。</p>
</div>
<div class="section" id="id5">
<h3>11.2.2  结构域<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>结构域对象的id是一个整数，得自该结构域在被解析的文件中的位置（自动的从0开始标记）。晶体结构通常只有一个结构域（id为0），而NMR文件则含有多个结构域。然而许多PDB解析器都假定只有一个结构域， <tt class="docutils literal"><span class="pre">Bio.PDB</span></tt> 中的 <tt class="docutils literal"><span class="pre">Structure</span></tt> 就是为解决这个而设计的，它能轻易的处理含有多个结构域的PDB文件。</p>
<p>举例如下，从结构对象中获取第一个结构域：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">first_model</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>结构域对象储存着一个链对象的列表。</p>
</div>
<div class="section" id="id6">
<h3>11.2.3  链<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>链对象的id取自PDB/mmCIF文件中链的标识符，是个单字符（通常是一个字母）。结构域中的链都有一个唯一的id。例如，从一个结构域对象取出标识符为“A”的链：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">chain_A</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="s">&quot;A&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>链对象储存着一个残基对象的列表。</p>
</div>
<div class="section" id="id7">
<h3>11.2.4  残基<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt>一个残基标识符是三个元素组成的元组：</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt><strong>hetero-field</strong> (hetfield)，即：</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">'W'</span></tt> 代表水分子</li>
<li>氨基酸残基名字后面紧跟的 <tt class="docutils literal"><span class="pre">'H_'</span></tt> 代表其他hetero残基（例如 <tt class="docutils literal"><span class="pre">'H_GLC'</span></tt> 表示一个葡萄糖分子）</li>
<li>空值表示标准的氨基酸和核酸</li>
</ul>
</dd>
</dl>
<p>图表在 <a class="reference external" href="#hetero%20problems">11.4.1</a> 部分描述。</p>
</li>
<li><p class="first"><strong>序列标识符</strong> （resseq），一个描述改残基在链上位置的整数（如100）；</p>
</li>
<li><p class="first"><strong>插入码</strong> （icode），一个字符串，如“A”。插入码有时候用来保持合适residue numbering scheme。一个Ser80的点突变（在Thr80和Asn81间插入）会有如下的序列标识符和插入码：Thr 80 A, Ser 80 B, Asn 81。通过这种方式，residue numbering scheme保持与野生型结构一致。</p>
</li>
</ul>
</dd>
</dl>
<p>上述葡萄糖的id可以是 <tt class="docutils literal"><span class="pre">(’H_GLC’,</span> <span class="pre">100,</span> <span class="pre">’A’)</span></tt> 。如果hetero标签和插入码为空，序列标识符为：</p>
<blockquote>
<div># Full id
&gt;&gt;&gt; residue=chain[(&#8216; &#8216;, 100, &#8216; &#8216;)]
# Shortcut id
&gt;&gt;&gt; residue=chain[100]</div></blockquote>
<p>hetero标签的起因是许多许多PDB文件用相同的序列标识符表示氨基酸和hetero残基或水分子，这会产生一个很明显的问题如果不是用hetero标签的话。</p>
<p>不令人吃惊的是，一个Residue对象存储这一系列的子Atom，也包含一个表示残基名字的字符串（如 “ASN”）和残基的片段标识符（这对X-PLOR的用户来说很熟悉，但是在SMCRA数据结构的构建红却不使用）。</p>
<p>让我们来看一些例子。插入码为空的Asn 10的残基id可为 <tt class="docutils literal"><span class="pre">(’</span> <span class="pre">’,</span> <span class="pre">10,</span> <span class="pre">’</span> <span class="pre">’)</span></tt> ；Water 10的残基id为 <tt class="docutils literal"><span class="pre">(’W’,</span> <span class="pre">10,</span> <span class="pre">’</span> <span class="pre">’)``；一个序列标识符是10的葡萄糖分子（一个残基名字是GLC的hetero残基）的残基id为</span> <span class="pre">``(’H_GLC’,</span> <span class="pre">10,</span> <span class="pre">’</span> <span class="pre">’)</span></tt> 。在这种情况下，三个相同插入码和序列标识符的残基可以位于同一条链上，因为他们的残基id是不同的。</p>
<p>在大多数情况下，hetflag和插入码都会为空，如 <tt class="docutils literal"><span class="pre">(’</span> <span class="pre">’,</span> <span class="pre">10,</span> <span class="pre">’</span> <span class="pre">’)</span></tt> 。在那些情况下，序列标识符可以用来作为完整的id：</p>
<blockquote>
<div>&gt;&gt;&gt;# use full id
&gt;&gt;&gt; res10 = chain[(&#8216; &#8216;, 10, &#8216; &#8216;)]
&gt;&gt;&gt;# use shortcut
&gt;&gt;&gt; res10 = chain[10]</div></blockquote>
<p>在Chain上的每个Residue对象都应该有一个唯一的id。然而，无序残基以一种特别的方式对待，详见 <a class="reference external" href="#point%20mutations">11.3.3</a> 。</p>
<p>一个Residue对象还有如下额外的方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">get_resname</span><span class="p">()</span>       <span class="c"># returns the residue name, e.g. &quot;ASN&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">is_disordered</span><span class="p">()</span>     <span class="c"># returns 1 if the residue has disordered atoms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">get_segid</span><span class="p">()</span>         <span class="c"># returns the SEGID, e.g. &quot;CHN1&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">has_id</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>        <span class="c"># test if a residue has a certain atom</span>
</pre></div>
</div>
<p>你可以用 <tt class="docutils literal"><span class="pre">is_aa(residue)</span></tt> 来测试一个Residue对象是否是氨基酸。</p>
</div>
<div class="section" id="atom">
<h3>11.2.5  原子Atom<a class="headerlink" href="#atom" title="Permalink to this headline">¶</a></h3>
<p>Atom对象储存这所有和原子有关的数据，没有子类。原子的id是它的原子名字（如，“OG”代表Ser残基侧链的氧原子）。在Residue中Atom的id需要是唯一的。而且，对于无序原子会产生异常，见 <a class="reference external" href="#disordered%20atoms">11.3.2</a> 描述。</p>
<p>原子id是简单的原子名字（如 <tt class="docutils literal"><span class="pre">’CA’</span></tt> ）。在实际中，原子名字通过去除PDB文件中原子名字中的空格创建的。</p>
<p>可是，在PDB文件中空格可以是原子名字的一部分。通常，钙原子称为 <tt class="docutils literal"><span class="pre">’CA..’</span></tt> 是为了和Cα原子（叫做 <tt class="docutils literal"><span class="pre">’.CA.’</span></tt> ）区分开。在这种情况，如果空格去除则会产生问题（如统一个残基中的两个原子都叫做 <tt class="docutils literal"><span class="pre">’CA’</span></tt> ），所以空格保留。</p>
<p>在PDB文件中，一个原子名字有4个字符组成，通常头尾皆为空格。为了方便使用空格经常被移除（在PDB文件中氨基酸的Cα原子标记为“.CA.”，点表示空格）。为了生成原子名字（然后是原子id），空格会被移除，除非回造成名字冲突（如两个Atom对象有相同的名字和id）。对于后者，会尝试原子名字包含空格。这种情况可能会发生当残基含名字为“.CA.”和“CA..”的原子，尽管这不怎么可能。</p>
<p>储存的原子数据包括原子名字，原子坐标（如果有的话还包括标准差），B因子（包括anisotropicB因子和可能存在的标准差），altloc标识符和完整的包括空格的原子名字。少用有时没有在PDB文件中存储的原子序号和原子电荷。</p>
<p>为了操纵原子坐标，可以用 <tt class="docutils literal"><span class="pre">’CA’</span></tt> 对象的 <tt class="docutils literal"><span class="pre">transform</span></tt> 方法。用 <tt class="docutils literal"><span class="pre">set_coord</span></tt> 方法可以直接指定原子坐标。</p>
<p>一个Atom对象还有如下额外的方法：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span>       <span class="c"># atom name (spaces stripped, e.g. &quot;CA&quot;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_id</span><span class="p">()</span>         <span class="c"># id (equals atom name)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_coord</span><span class="p">()</span>      <span class="c"># atomic coordinates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>     <span class="c"># atomic coordinates as Vector object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_bfactor</span><span class="p">()</span>    <span class="c"># isotropic B factor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_occupancy</span><span class="p">()</span>  <span class="c"># occupancy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_altloc</span><span class="p">()</span>     <span class="c"># alternative location specifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_sigatm</span><span class="p">()</span>     <span class="c"># standard deviation of atomic parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_siguij</span><span class="p">()</span>     <span class="c"># standard deviation of anisotropic B factor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_anisou</span><span class="p">()</span>     <span class="c"># anisotropic B factor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">get_fullname</span><span class="p">()</span>   <span class="c"># atom name (with spaces, e.g. &quot;.CA.&quot;)</span>
</pre></div>
</div>
<p>siguij，anisotropic B因子和sigatm Numpy可以用来表示原子坐标。</p>
<p>方法 <tt class="docutils literal"><span class="pre">get_vector</span></tt> 回返回一个代表 <tt class="docutils literal"><span class="pre">Atom</span></tt>  对象坐标的 <tt class="docutils literal"><span class="pre">Vector</span></tt> 对象，可以对原子坐标做向量操作。 <tt class="docutils literal"><span class="pre">Vector</span></tt> 实现了完整的三维向量操作、矩阵乘法（包括左和右）和一些高级的旋转相关的操作。</p>
<p>作为Bio.PDB的 <tt class="docutils literal"><span class="pre">Vector</span></tt> 模块的性能展示的一个例子，假设你查找Gly氨基酸残基的Cβ原子的位置,如果存在的话。将Gly残基的N原子沿Cα-C旋转-120度，能大致将其放在一个虚拟的Cβ原子的位置上。下面是使用 <tt class="docutils literal"><span class="pre">Vector</span></tt> 模块中的``rotaxis`` 方法（能用来完成绕一个轴的旋转）如何实现的：</p>
<blockquote>
<div># get atom coordinates as vectors
&gt;&gt;&gt; n = residue[&#8216;N&#8217;].get_vector()
&gt;&gt;&gt; c = residue[&#8216;C&#8217;].get_vector()
&gt;&gt;&gt; ca = residue[&#8216;CA&#8217;].get_vector()
# center at origin
&gt;&gt;&gt; n = n - ca
&gt;&gt;&gt; c = c - ca
# find rotation matrix that rotates n
# -120 degrees along the ca-c vector
&gt;&gt;&gt; rot = rotaxis(-pi * 120.0/180.0, c)
# apply rotation to ca-n vector
&gt;&gt;&gt; cb_at_origin = n.left_multiply(rot)
# put on top of ca atom
&gt;&gt;&gt; cb = cb_at_origin+ca</div></blockquote>
<p>这个例子展示了在原子数据上能进行非常不一样的向量操作的可能性，这些操作是非常有用的。另外，所有有用的向量操作（交叉（用 <tt class="docutils literal"><span class="pre">*</span></tt><tt class="docutils literal"><span class="pre">*</span></tt> ），点积（用 <tt class="docutils literal"><span class="pre">*</span></tt> ），angle, norm等）和上述提到的 <tt class="docutils literal"><span class="pre">rotaxis</span></tt> 函数，``Vector`` 模块也有方法实现将一个向量叠加（ <tt class="docutils literal"><span class="pre">rotmat</span></tt> ）或反射（ <tt class="docutils literal"><span class="pre">refmat</span></tt> ）到两外一个向量上。</p>
</div>
<div class="section" id="atom-residue-chain-model">
<h3>11.2.6  从结构分子中提取特定的 <tt class="docutils literal"><span class="pre">Atom/Residue/Chain/Model</span></tt><a class="headerlink" href="#atom-residue-chain-model" title="Permalink to this headline">¶</a></h3>
<p>例子如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span> <span class="o">=</span> <span class="n">residue</span><span class="p">[</span><span class="s">&#39;CA&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>还有比较简单的方式：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;A&#39;</span><span class="p">][</span><span class="mi">100</span><span class="p">][</span><span class="s">&#39;CA&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="disorder">
<h2>11.3  Disorder<a class="headerlink" href="#disorder" title="Permalink to this headline">¶</a></h2>
<p>Bio.PDB能够处理无序原子和点突变（比如Gly和Ala残基在相同位置上）。</p>
<div class="section" id="id8">
<h3>11.3.1  一般途径<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>杂乱性可以从两个角度来解决：原子和残基的角度。一般来说，我们尝试压缩所有的会增加杂乱性。如果你仅仅想遍历所有Cα原子，你不必关注一些含杂乱侧链的残基。另一方面，应该考虑在数据结构中描述杂乱性。因此，杂乱原子或残基存储在特定的对象中表现得毫无杂乱性。这可以通过描述杂乱原子或残基的子集来完成。至于哪个子集（例如用到Ser残基侧链上的两个杂乱的OG原子）被挑选出来由用户来决定。</p>
</div>
<div class="section" id="id9">
<h3>11.3.2  杂乱的原子<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>杂乱原子可以用普通的 <tt class="docutils literal"><span class="pre">Atom</span></tt> 对象来描述，但是所有描述相同物理物理原子的 <tt class="docutils literal"><span class="pre">Atom</span></tt> 对象储存在一个 <tt class="docutils literal"><span class="pre">DisorderedAtom</span></tt> 对象中（见图Fig. <a class="reference external" href="#fig:smcra">11.1</a> ）。 <tt class="docutils literal"><span class="pre">DisorderedAtom</span></tt> 对象中每个 <tt class="docutils literal"><span class="pre">Atom</span></tt> 对象都可以被它的altloc标识符唯一的索引。 <tt class="docutils literal"><span class="pre">DisorderedAtom</span></tt> 对象转寄所有uncaught method calls到选定的Atom对象，用过它的altloc标识符。以这种方式，原子杂乱性哪呢个正确的呗描述而没有额外的复杂性。换言之，如果你对杂乱原子不敢兴趣，你不会被它困扰。</p>
<p>每个杂乱原子有个特有的altloc标识符。你可以指定一个 <tt class="docutils literal"><span class="pre">DisorderedAtom</span></tt> 对象表现得像 <tt class="docutils literal"><span class="pre">Atom</span></tt> 对象和特定的altloc标识符关联：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">disordered_select</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span> <span class="c"># select altloc A atom</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">atom</span><span class="o">.</span><span class="n">get_altloc</span><span class="p">()</span>
<span class="go">&quot;A&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span><span class="o">.</span><span class="n">disordered_select</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span> <span class="c"># select altloc B atom</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">atom</span><span class="o">.</span><span class="n">get_altloc</span><span class="p">()</span>
<span class="go">&quot;B&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3>11.3.3  杂乱的残基<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id11">
<h4>普通例子<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>最常见的例子是一个残基包含一个或多个杂乱原子。这显然可以通过用DisorderedAtom对象描述这些杂乱原子来解决，并将DisorderedAtom对象保存在Residue对象中想正常的Atom对象一样。DisorderedAtom对象通过转寄所有uncaught method calls到其中一个Atom对象（被选中的Atom对象）一个表现的非常像正常的原子（事实上这个原子有最高的使用率）。</p>
</div>
<div class="section" id="id12">
<h4>点突变<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<p>当点突变导致杂乱会产生一个特殊的例子，例如，当多肽中有两个或更多的点突变展示在晶体结构中。这个例子可以在PDB结构1EN2中找到。</p>
<p>既然这些残基属于不同的残基类型（举例说Ser 60 和Cys 60），他们不应该存储在一个 <tt class="docutils literal"><span class="pre">Residue</span></tt> 对象中像普通情况一样。在这是，每个残基被描述成 <tt class="docutils literal"><span class="pre">Residue</span></tt> 对象，所有 <tt class="docutils literal"><span class="pre">Residue</span></tt> 对象保存在一个 <tt class="docutils literal"><span class="pre">DisorderedResidue</span></tt> 对象中（见 Fig. <a class="reference external" href="#fig:smcra">11.1</a> ）。</p>
<p><tt class="docutils literal"><span class="pre">DisorderedResidue</span></tt> 对象转寄所有uncaught methods到选定的 <tt class="docutils literal"><span class="pre">Residue</span></tt> 对象（默认下最后一个 <tt class="docutils literal"><span class="pre">Residue</span></tt> 对象被添加），然后表现得的一个正常的残基一样。在 <tt class="docutils literal"><span class="pre">DisorderedResidue</span></tt> 中的每个 <tt class="docutils literal"><span class="pre">Residue</span></tt> 对象通过残基名字被势必人出来。在上述例子中，残基Ser60在 <tt class="docutils literal"><span class="pre">DisorderedResidue</span></tt> 对象中的id为“SER”，而残基Cys 60则是“CYS”。他们能在 <tt class="docutils literal"><span class="pre">DisorderedResidue</span></tt> 中通过这个id选择现行的 <tt class="docutils literal"><span class="pre">Residue</span></tt> 对象。</p>
<p>例子：假设一个子类在10位有一个由Ser和Cys构成的点突变。让这个链的10位残基表现为Cys残基。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span><span class="o">.</span><span class="n">disordered_select</span><span class="p">(</span><span class="s">&#39;CYS&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>另外，你能获得所有 <tt class="docutils literal"><span class="pre">Atom</span></tt> 对象的列表（如所有 <tt class="docutils literal"><span class="pre">DisorderedAtom</span></tt> 对象从他们各自的 <tt class="docutils literal"><span class="pre">Atom</span></tt> 对象中’unpacked’），通过使用 <tt class="docutils literal"><span class="pre">(Disordered)Residue</span></tt> 对象的 <tt class="docutils literal"><span class="pre">get_unpacked_list</span></tt> 方法。</p>
</div>
</div>
</div>
<div class="section" id="hetero">
<h2>11.4  Hetero残基<a class="headerlink" href="#hetero" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id13">
<h3>11.4.1  相关问题<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>关于hetero残基的一个很普遍的问题是若干hetero和非hetero残基在同一条链中有同样的序列标识符和插入码。因此，为了生成每个hetero残基唯一的id，水分子和其他hetero残基应该以不同的方式来对待。</p>
<p>记住Residue残基有一个元组（hetfield, resseq, icode）作为id。hetfield值为空(“ ”)表示为氨基酸和核酸；为一个字符串表示水分子和其他hetero残基。hetfield的内容将在下面解释。</p>
</div>
<div class="section" id="id14">
<h3>11.4.2  水分子<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>water residue的hetfield字符串由字母“W”组成。所以一个典型的水分子的残基id为(“W”, 1, “ ”)。</p>
</div>
<div class="section" id="id15">
<h3>11.4.3  其他hetero残基<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>其他hetero残基的hetfield字符以“H_”起始，后接残基名字。一个葡萄糖分子的残基名称为“GLC”，则hetfield字符为“H_GLC”；它的残基id可以是(“H_GLC”, 1,
“ ”)。</p>
</div>
</div>
<div class="section" id="structure">
<h2>11.5  操纵Structure对象<a class="headerlink" href="#structure" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Bio.PDB.PDBParser</span> <span class="kn">import</span> <span class="n">PDBParser</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">PDBParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">,</span> <span class="s">&quot;1fat.pdb&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain</span> <span class="o">=</span> <span class="n">model</span><span class="p">[</span><span class="s">&quot;A&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom</span> <span class="o">=</span> <span class="n">residue</span><span class="p">[</span><span class="s">&quot;CA&quot;</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">PDBParser</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">get_structure</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">,</span> <span class="s">&#39;pdb1fat.ent&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">structure</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">model</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="p">:</span>
<span class="gp">... </span>                <span class="k">print</span> <span class="n">atom</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>如果你想遍历一个结构中所有原子，这儿有个捷径可以走：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_atoms</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">atom</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>类似地，遍历一条链中的原子，可以这么做：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">get_atoms</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">atom</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>或者，如果你想遍历在一条链上的所有残基：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">residues</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_residues</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">residues</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">residue</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>你也可以用 <tt class="docutils literal"><span class="pre">Selection.unfold_entities</span></tt> 函数来从一个结构中获取所有残基：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">res_list</span> <span class="o">=</span> <span class="n">Selection</span><span class="o">.</span><span class="n">unfold_entities</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="s">&#39;R&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>或者从链上获得所有原子：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">atom_list</span> <span class="o">=</span> <span class="n">Selection</span><span class="o">.</span><span class="n">unfold_entities</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>明显的是， <tt class="docutils literal"><span class="pre">A=atom,</span> <span class="pre">R=residue,</span> <span class="pre">C=chain,</span> <span class="pre">M=model,</span> <span class="pre">S=structure</span></tt> 。你可以用此返回上一层，如从一个 <tt class="docutils literal"><span class="pre">Atoms</span></tt> 列表回溯到一个唯一的 <tt class="docutils literal"><span class="pre">Residue</span></tt> 或 <tt class="docutils literal"><span class="pre">Chain</span></tt> 的列表：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">residue_list</span> <span class="o">=</span> <span class="n">Selection</span><span class="o">.</span><span class="n">unfold_entities</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="s">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chain_list</span> <span class="o">=</span> <span class="n">Selection</span><span class="o">.</span><span class="n">unfold_entities</span><span class="p">(</span><span class="n">atom_list</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>更多信息详见API文档。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">residue_id</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;H_GLC&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&quot; &quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="n">residue_id</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">chain</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>   <span class="n">residue_id</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">get_id</span><span class="p">()</span>
<span class="gp">... </span>   <span class="n">hetfield</span> <span class="o">=</span> <span class="n">residue_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">... </span>   <span class="k">if</span> <span class="n">hetfield</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s">&quot;H&quot;</span><span class="p">:</span>
<span class="gp">... </span>       <span class="k">print</span> <span class="n">residue_id</span>
<span class="gp">...</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">chain</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">has_id</span><span class="p">(</span><span class="s">&quot;CA&quot;</span><span class="p">):</span>
<span class="gp">... </span>                <span class="n">ca</span> <span class="o">=</span> <span class="n">residue</span><span class="p">[</span><span class="s">&quot;CA&quot;</span><span class="p">]</span>
<span class="gp">... </span>                <span class="k">if</span> <span class="n">ca</span><span class="o">.</span><span class="n">get_bfactor</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">50.0</span><span class="p">:</span>
<span class="gp">... </span>                    <span class="k">print</span> <span class="n">ca</span><span class="o">.</span><span class="n">get_coord</span><span class="p">()</span>
<span class="gp">...</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">chain</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">is_disordered</span><span class="p">():</span>
<span class="gp">... </span>                <span class="n">resseq</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">get_id</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span>                <span class="n">resname</span> <span class="o">=</span> <span class="n">residue</span><span class="o">.</span><span class="n">get_resname</span><span class="p">()</span>
<span class="gp">... </span>                <span class="n">model_id</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_id</span><span class="p">()</span>
<span class="gp">... </span>                <span class="n">chain_id</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">get_id</span><span class="p">()</span>
<span class="gp">... </span>                <span class="k">print</span> <span class="n">model_id</span><span class="p">,</span> <span class="n">chain_id</span><span class="p">,</span> <span class="n">resname</span><span class="p">,</span> <span class="n">resseq</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>这需要确定的是SMCRA数据结构表现得如同altloc A原子存在。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">chain</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="n">residue</span><span class="o">.</span><span class="n">is_disordered</span><span class="p">():</span>
<span class="gp">... </span>                <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">get_list</span><span class="p">():</span>
<span class="gp">... </span>                    <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">is_disordered</span><span class="p">():</span>
<span class="gp">... </span>                        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">disordered_has_id</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">):</span>
<span class="gp">... </span>                            <span class="n">atom</span><span class="o">.</span><span class="n">disordered_select</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">)</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>为了从一个结构中提取多肽，需要用 <tt class="docutils literal"><span class="pre">PolypeptideBuilder</span></tt> 从 <tt class="docutils literal"><span class="pre">Structure</span></tt> 构建一个 <tt class="docutils literal"><span class="pre">Polypeptide</span></tt> 对象的列表，如下所示：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">model_nr</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polypeptide_list</span> <span class="o">=</span> <span class="n">build_peptides</span><span class="p">(</span><span class="n">structure</span><span class="p">,</span> <span class="n">model_nr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">polypeptide</span> <span class="ow">in</span> <span class="n">polypeptide_list</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">polypeptide</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>Polypeptide对象是Residue对象的一个简单UserList，总是从单结构域中创建（在此例中为结构域1）。你可以从刚生成的 <tt class="docutils literal"><span class="pre">Polypeptide</span></tt> 对象提取序列作为 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象，或获得Cα原子的列表。多肽可以通过C-N 或a Cα-Cα距离标准来建立。</p>
<p>例子：</p>
<blockquote>
<div># Using C-N
&gt;&gt;&gt; ppb=PPBuilder()
&gt;&gt;&gt; for pp in ppb.build_peptides(structure):
...     print pp.get_sequence()
...
# Using CA-CA
&gt;&gt;&gt; ppb=CaPPBuilder()
&gt;&gt;&gt; for pp in ppb.build_peptides(structure):
...     print pp.get_sequence()
...</div></blockquote>
<p>需要注意的是，在上述例子中这个结构中，只有结构域0被 <tt class="docutils literal"><span class="pre">PolypeptideBuilder</span></tt> 考虑。尽管如此，还是可以用 <tt class="docutils literal"><span class="pre">PolypeptideBuilder</span></tt> 从 <tt class="docutils literal"><span class="pre">Model</span></tt> 和 <tt class="docutils literal"><span class="pre">Chain</span></tt> 对象创建 <tt class="docutils literal"><span class="pre">Polypeptide</span></tt> 对象。</p>
<p>要做的第一件事就是从结构中提取所有多肽（如上述）。每条多肽的序列可以轻易的通过 <tt class="docutils literal"><span class="pre">Polypeptide</span></tt> 对象获得。这个序列当作Biopython中 <tt class="docutils literal"><span class="pre">Seq</span></tt> 对象来描述，它的字母表由 <tt class="docutils literal"><span class="pre">ProteinAlphabet</span></tt> 对象来定义。</p>
<p>例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">polypeptide</span><span class="o">.</span><span class="n">get_sequence</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">seq</span>
<span class="go">Seq(&#39;SNVVE...&#39;, &lt;class Bio.Alphabet.ProteinAlphabet&gt;)</span>
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h2>11.6  结构分析<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id17">
<h3>11.6.1  测定距离<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>两个已叠加的原子通过减法运算可以返回两个原子之间的距离。</p>
<blockquote>
<div># Get some atoms
&gt;&gt;&gt; ca1 = residue1[&#8216;CA&#8217;]
&gt;&gt;&gt; ca2 = residue2[&#8216;CA&#8217;]
# Simply subtract the atoms to get their distance
&gt;&gt;&gt; distance = ca1-ca2</div></blockquote>
</div>
<div class="section" id="id18">
<h3>11.6.2  测定角度<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<p>用向量表示原子坐标，然后用 <tt class="docutils literal"><span class="pre">Vector</span></tt> 模块中的 <tt class="docutils literal"><span class="pre">calc_angle</span></tt> 函数可以计算角度。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vector1</span> <span class="o">=</span> <span class="n">atom1</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector2</span> <span class="o">=</span> <span class="n">atom2</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector3</span> <span class="o">=</span> <span class="n">atom3</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angle</span> <span class="o">=</span> <span class="n">calc_angle</span><span class="p">(</span><span class="n">vector1</span><span class="p">,</span> <span class="n">vector2</span><span class="p">,</span> <span class="n">vector3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="measuring-torsion-angles">
<h3>11.6.3  测定扭转角Measuring torsion angles<a class="headerlink" href="#measuring-torsion-angles" title="Permalink to this headline">¶</a></h3>
<p>用向量表示原子坐标，然后用 <tt class="docutils literal"><span class="pre">Vector</span></tt> 模块中的 <tt class="docutils literal"><span class="pre">calc_dihedral</span></tt> 函数可以计算角度。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">vector1</span> <span class="o">=</span> <span class="n">atom1</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector2</span> <span class="o">=</span> <span class="n">atom2</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector3</span> <span class="o">=</span> <span class="n">atom3</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector4</span> <span class="o">=</span> <span class="n">atom4</span><span class="o">.</span><span class="n">get_vector</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">angle</span> <span class="o">=</span> <span class="n">calc_dihedral</span><span class="p">(</span><span class="n">vector1</span><span class="p">,</span> <span class="n">vector2</span><span class="p">,</span> <span class="n">vector3</span><span class="p">,</span> <span class="n">vector4</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="determining-atom-atom-contacts">
<h3>11.6.4  确定原子-原子接触Determining atom-atom contacts<a class="headerlink" href="#determining-atom-atom-contacts" title="Permalink to this headline">¶</a></h3>
<p>用 <tt class="docutils literal"><span class="pre">NeighborSearch</span></tt> 实现临近查询。临近查询能够使用用C语言写的KD树模块（见 <tt class="docutils literal"><span class="pre">Bio.KDTree</span></tt> ）来比较快速的实现。它也包含了一个比较快速的方法找出一定距离内所有成对的点。</p>
</div>
<div class="section" id="id19">
<h3>11.6.5  叠加两个结构<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>可以用 <tt class="docutils literal"><span class="pre">Superimposer</span></tt> 对象将两组坐标数据重叠。这个对象计算叠加和转化矩阵，这个矩阵通过叠加两个原子的列表以他们的RMSD最小的方式叠加在一起得到的矩阵。当然这两个列表含有相同数目的原子。 <tt class="docutils literal"><span class="pre">Superimposer</span></tt> 对象将叠加/转化应用在原子上。叠加和转化作为元组储存在 <tt class="docutils literal"><span class="pre">Superimposer</span></tt> 对象的 <tt class="docutils literal"><span class="pre">rotran</span></tt> 属性（注意的是叠加是right multiplying），RMSD储存在属性 <tt class="docutils literal"><span class="pre">rmsd</span></tt> 中。</p>
<p><tt class="docutils literal"><span class="pre">Superimposer</span></tt> 使用的算法来自[<a class="reference external" href="#golub1989">17</a>,
Golub &amp; Van Loan]，用有意义的分解值（这在 <tt class="docutils literal"><span class="pre">Bio.SVDSuperimposer</span></tt> 模块中实现）。</p>
<p>例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sup</span> <span class="o">=</span> <span class="n">Superimposer</span><span class="p">()</span>
<span class="go"># Specify the atom lists</span>
<span class="go"># &#39;fixed&#39; and &#39;moving&#39; are lists of Atom objects</span>
<span class="go"># The moving atoms will be put on the fixed atoms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sup</span><span class="o">.</span><span class="n">set_atoms</span><span class="p">(</span><span class="n">fixed</span><span class="p">,</span> <span class="n">moving</span><span class="p">)</span>
<span class="go"># Print rotation/translation/rmsd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sup</span><span class="o">.</span><span class="n">rotran</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sup</span><span class="o">.</span><span class="n">rms</span>
<span class="go"># Apply rotation/translation to the moving atoms</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sup</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">moving</span><span class="p">)</span>
</pre></div>
</div>
<p>为了将结构根据他们的现行的位点叠加在一起，用active位点的原子计算叠加和转化矩阵（类似上述），将那些应用到整个分子。</p>
</div>
<div class="section" id="id20">
<h3>11.6.6  相互映射这两个结构的残基到对方<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<p>首先，创建一个FASTA格式的比对文件，然后用``StructureAlignment`` 类。这个类也可以用来映射多余两个结构和比对。</p>
</div>
<div class="section" id="half-sphere-exposure">
<h3>11.6.7  计算Half Sphere Exposure<a class="headerlink" href="#half-sphere-exposure" title="Permalink to this headline">¶</a></h3>
<p>Half Sphere Exposure (HSE)是一种新的，2D测量solvent exposure [<a class="reference external" href="#hamelryck2005">20</a>]。基本上，它计算围绕一个残基的Cα原子的个数，在它侧链的方向上，及反方向（在13 Å范围内）。除了简单，它还比其他solvent exposure测量工具好。</p>
<p>HSE有两种HSEα和HSEβ。前者仅用Cα原子的位置，而后者都用Cα和Cβ原子位置。HSE测定的通过 <tt class="docutils literal"><span class="pre">HSExposure</span></tt> 类计算的，也能计算原子接触数目。后者能返回一个将``Residue`` 对象映射到相应的HSEα,HSEβ和接触数目值的字典。</p>
<p>例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hse</span> <span class="o">=</span> <span class="n">HSExposure</span><span class="p">()</span>
<span class="go"># Calculate HSEalpha</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_ca</span> <span class="o">=</span> <span class="n">hse</span><span class="o">.</span><span class="n">calc_hs_exposure</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;CA3&#39;</span><span class="p">)</span>
<span class="go"># Calculate HSEbeta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_cb</span><span class="o">=</span><span class="n">hse</span><span class="o">.</span><span class="n">calc_hs_exposure</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;CB&#39;</span><span class="p">)</span>
<span class="go"># Calculate classical coordination number</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp_fs</span> <span class="o">=</span> <span class="n">hse</span><span class="o">.</span><span class="n">calc_fs_exposure</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="go"># Print HSEalpha for a residue</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">exp_ca</span><span class="p">[</span><span class="n">some_residue</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h3>11.6.8  确定二级结构<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h3>
<p>与这个功能，你需要安装DSSP（获得一个对学术免费的证书，参见 <tt class="docutils literal"><span class="pre">`http://www.cmbi.kun.nl/gv/dssp/</span></tt> &lt;<a class="reference external" href="http://www.cmbi.kun.nl/gv/dssp/">http://www.cmbi.kun.nl/gv/dssp/</a>&gt;`__ ）。然后用 <tt class="docutils literal"><span class="pre">DSSP</span></tt> 类，可以 <tt class="docutils literal"><span class="pre">Residue</span></tt> 对象到他们的二级结构上（和accessible surface area）。DSSP代码如下表所列 Table <a class="reference external" href="#cap:DSSP-codes">11.1</a> 。注意DSSP（程序及其相应的类）不能处理多个结构域！For this functionality, you need to install DSSP (and obtain a license
for it — free for academic use, see
<tt class="docutils literal"><span class="pre">`http://www.cmbi.kun.nl/gv/dssp/</span></tt> &lt;<a class="reference external" href="http://www.cmbi.kun.nl/gv/dssp/">http://www.cmbi.kun.nl/gv/dssp/</a>&gt;`__).
Then use the <tt class="docutils literal"><span class="pre">DSSP</span></tt> class, which maps <tt class="docutils literal"><span class="pre">Residue</span></tt> objects to their
secondary structure (and accessible surface area). The DSSP codes are
listed in Table <a class="reference external" href="#cap:DSSP-codes">11.1</a>. Note that DSSP (the program,
and thus by consequence the class) cannot handle multiple models!</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Code</td>
<td>Secondary structure</td>
</tr>
<tr class="row-even"><td>H</td>
<td>α-helix</td>
</tr>
<tr class="row-odd"><td>B</td>
<td>Isolated β-bridge residue</td>
</tr>
<tr class="row-even"><td>E</td>
<td>Strand</td>
</tr>
<tr class="row-odd"><td>G</td>
<td>3-10 helix</td>
</tr>
<tr class="row-even"><td>I</td>
<td>Π-helix</td>
</tr>
<tr class="row-odd"><td>T</td>
<td>Turn</td>
</tr>
<tr class="row-even"><td>S</td>
<td>Bend</td>
</tr>
<tr class="row-odd"><td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>Other</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">DSSP</span></tt> 类也可以用来计算残基的易接近的表面。但是也参考 <a class="reference external" href="#subsec:residue_depth">11.6.9</a> 。</p>
</div>
<div class="section" id="id22">
<h3>11.6.9  计算残基深度<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h3>
<p>残基深度残基的原子到solvent accessible surface的平均距离。它是个费城新颖和强大的描述solvent accessibility的参数。为了这个功能，你需要安装Michel Sanner的 MSMS程序（ <tt class="docutils literal"><span class="pre">`http://www.scripps.edu/pub/olson-web/people/sanner/html/msms_home.html</span></tt> &lt;<a class="reference external" href="http://www.scripps.edu/pub/olson-web/people/sanner/html/msms_home.html">http://www.scripps.edu/pub/olson-web/people/sanner/html/msms_home.html</a>&gt;`__ ）。然后用 <tt class="docutils literal"><span class="pre">ResidueDepth</span></tt> 类。这个类想字典一样将 <tt class="docutils literal"><span class="pre">Residue</span></tt> 对象映射到相应的元组（残基深度，Cα深度）。Cα深度是残基的Cα原子到solvent accessible surface的距离。</p>
<p>Residue depth is the average distance of a residue’s atoms from the
solvent accessible surface. It’s a fairly new and very powerful
parameterization of solvent accessibility. For this functionality, you
need to install Michel Sanner’s MSMS program
(<tt class="docutils literal"><span class="pre">`http://www.scripps.edu/pub/olson-web/people/sanner/html/msms_home.html</span></tt> &lt;<a class="reference external" href="http://www.scripps.edu/pub/olson-web/people/sanner/html/msms_home.html">http://www.scripps.edu/pub/olson-web/people/sanner/html/msms_home.html</a>&gt;`__).
Then use the <tt class="docutils literal"><span class="pre">ResidueDepth</span></tt> class. This class behaves as a dictionary
which maps <tt class="docutils literal"><span class="pre">Residue</span></tt> objects to corresponding (residue depth, Cα
depth) tuples. The Cα depth is the distance of a residue’s Cα atom to
the solvent accessible surface.</p>
<p>例子：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">structure</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rd</span> <span class="o">=</span> <span class="n">ResidueDepth</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">pdb_file</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">residue_depth</span><span class="p">,</span> <span class="n">ca_depth</span><span class="o">=</span><span class="n">rd</span><span class="p">[</span><span class="n">some_residue</span><span class="p">]</span>
</pre></div>
</div>
<p>你也可以获得分子表面本身（通过 <tt class="docutils literal"><span class="pre">get_surface</span></tt> 函数），以Python数组的形式的形式和表面点。You can also get access to the molecular surface itself (via the
<tt class="docutils literal"><span class="pre">get_surface</span></tt> function), in the form of a Numeric Python array with
the surface points.</p>
</div>
</div>
<div class="section" id="id23">
<h2>11.7  PDB文件中的常见问题<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h2>
<p>都知道一些PDB文件有语义错误（不是结构本身的错误，而是在PDB文件中描述时出错）。Bio.PDB可以有两种途径来处理这个问题。PDBParser对象能以两种方式处理：严格（restrictive）方式和宽松（permissive）方式（默认方式）：</p>
<p>例子:</p>
<blockquote>
<div># Permissive parser
&gt;&gt;&gt; parser = PDBParser(PERMISSIVE=1)
&gt;&gt;&gt; parser = PDBParser() # The same (default)
# Strict parser
&gt;&gt;&gt; strict_parser = PDBParser(PERMISSIVE=0)</div></blockquote>
<dl class="docutils">
<dt>在宽松状态（默认），还有错误的PDB文件会被认为是“正确的”（比如说一些残基或原子丢失）。这些错误包括：</dt>
<dd><ul class="first last simple">
<li>多个残基使用同一个标识符</li>
<li>多个原子使用统一个标识符（考虑altloc识别符）</li>
</ul>
</dd>
</dl>
<p>这些错误暗示了PDB文件中确实在错误（详情见 [<a class="reference external" href="#hamelryck2003a">18</a>, Hamelryck and Manderick, 2003] ）。在严格模式，PDB文件中的这些错误会报错，这能帮助发现PDB文件的存在的错误。</p>
<p>有些错误能自动修正。正常情况下，每个无序原子应该会有一个非空altloc标识符，可是有些结构没有遵循这个惯例，在用同一个原子上会同时存在两个无序位置的空的和非空的标识符。这个错误能够以正确的方式被解析。</p>
<p>有时候一个结构会有这样的情况：一部分残基属于A链，接下来一部分残基属于B链，然后又有一部分残基属于A链，这种链称为“断链”，这也能被正确的解析。</p>
<div class="section" id="id24">
<h3>11.7.1  例子<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h3>
<p>PDBParser/Structure类经将近800个结构测试（每个都属于不同的SCOP超家族），总共花费20分钟左右，也就是说平均每个结构只需1.5秒。在一台1000 MHz的PC上解析巨大的包含近64000个原子的核糖体亚单位（1FKK）只需10秒。</p>
<p>当明确的数据结构不能建立的时候会有三个异常发生。在这三个异常中，可能的起因是PDB文件中本应修正的错误没有被修正。产生异常总要比冒险不正确描述一个在那样的数据结构中的结构分子好的多。</p>
<div class="section" id="id25">
<h4>11.7.1.1  重复残基<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h4>
<p>一个结构分子在相同的序列标识符（resseq3）和icode的链上存在两个相同的氨基酸残基。仔细观察可以发现这条链包含残基：Thr A3, …, Gly A202, Leu A3；很明显第二个Leu A3应该是Leu A203。类似的情况也存在于1FFK结构上（含残基Gly B64, Met B65, Glu B65, Thr B67；第二个Glu B65应该是Glu B66）。</p>
</div>
<div class="section" id="id26">
<h4>11.7.1.2  重复原子<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h4>
<p>结构1EJG含有在A链22位的Ser/Pro点突变。依次，Ser 22含一些杂乱原子。和期望的一样，所有属于 Ser 22的原子都有一个非空的altloc标识符（B或C）。所有Pro 22的原子都为altloc A，除了含空altloc的N原子。这会申城一个异常，因为所有属于一个点突变的两个残基的原子都应该有非空的altloc。这导致这个原子被Ser 和 Pro 22共用，Ser22丢失了这个N原子。再者，这意味着在文件中的问题：这个N原子应该在Ser和Pro残基中都有描述，都与合适的altloc标识符关联。
Structure 1EJG contains a Ser/Pro point mutation in chain A at position
22. In turn, Ser 22 contains some disordered atoms. As expected, all
atoms belonging to Ser 22 have a non-blank altloc specifier (B or C).
All atoms of Pro 22 have altloc A, except the N atom which has a blank
altloc. This generates an exception, because all atoms belonging to two
residues at a point mutation should have non-blank altloc. It turns out
that this atom is probably shared by Ser and Pro 22, as Ser 22 misses
the N atom. Again, this points to a problem in the file: the N atom
should be present in both the Ser and the Pro residue, in both cases
associated with a suitable altloc identifier.</p>
</div>
</div>
<div class="section" id="id27">
<h3>11.7.2  自动修正<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h3>
<p>一些错误比较普遍，能够在没有太大解释错误的风险下被修改。这些错误如下所述。</p>
<div class="section" id="altloc">
<h4>11.7.2.1  无序原子的空altloc<a class="headerlink" href="#altloc" title="Permalink to this headline">¶</a></h4>
<p>正常情况下，每个无序原子应该会有一个非空altloc标识符，可是有些结构没有遵循这个惯例，在用同一个原子上会同时存在两个无序位置的空的和非空的标识符。这个错误能够以正确的方式被解析。</p>
</div>
<div class="section" id="id28">
<h4>11.7.2.2  断链<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h4>
<p>有时候一个结构会有这样的情况：一部分残基属于A链，接下来一部分残基属于B链，然后又有一部分残基属于A链，这种链称为“断链”，这也能被正确的解析。</p>
</div>
</div>
<div class="section" id="fatal-errors">
<h3>11.7.3  致命错误Fatal errors<a class="headerlink" href="#fatal-errors" title="Permalink to this headline">¶</a></h3>
<p>有时候一个PDB文件不能被明确的解释，这会产生异常而不是猜测和冒出错的风险，等待用户去修正这个PDB文件。这些异常如下所述。</p>
<div class="section" id="id29">
<h4>11.7.3.1  残基重复<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h4>
<p>所有在一条链上的残基应该有一个唯一的id，这id基于下述生成：</p>
<blockquote>
<div><ul class="simple">
<li>序列标识符（resseq）</li>
<li>插入码（icode）</li>
<li>hetfield字符（“W”代表水分子，残基名字后面的“H_”代表其他异性残基）</li>
<li>发生点突变的残基名字（在DisorderedResidue对象中保存Residue对象）</li>
</ul>
</div></blockquote>
<p>如果这样还不能生成一个唯一的id，则会生成异常。</p>
</div>
<div class="section" id="id30">
<h4>11.7.3.2  原子重复<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>一个残基上所有原子应该有一个唯一的id，这个id基于下述产生：</dt>
<dd><ul class="first last simple">
<li>原子名称（没有空格，否则会报错）</li>
<li>altloc标识符</li>
</ul>
</dd>
</dl>
<p>如果这不能生成一个唯一的id，则会生成异常。</p>
</div>
</div>
</div>
<div class="section" id="protein-data-bank">
<h2>11.8  访问Protein Data Bank<a class="headerlink" href="#protein-data-bank" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id31">
<h3>11.8.1  从Protein Data Bank下载结构<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h3>
<p>结构可以从PDB数据库（Protein Data Bank）通过 <tt class="docutils literal"><span class="pre">PDBList</span></tt> 对象的 <tt class="docutils literal"><span class="pre">retrieve_pdb_file</span></tt> 方法下载。这种方法的要点是结构在PDB中的唯一标识符。Structures can be downloaded from the PDB (Protein Data Bank) by using
the <tt class="docutils literal"><span class="pre">retrieve_pdb_file</span></tt> method on a <tt class="docutils literal"><span class="pre">PDBList</span></tt> object. The argument
for this method is the PDB identifier of the structure.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pdbl</span> <span class="o">=</span> <span class="n">PDBList</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdbl</span><span class="o">.</span><span class="n">retrieve_pdb_file</span><span class="p">(</span><span class="s">&#39;1FAT&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">PDBList</span></tt> 类也能作为命令行工具来使用：</p>
<blockquote>
<div>python PDBList.py 1fat</div></blockquote>
<p>下载的文件将以 <tt class="docutils literal"><span class="pre">pdb1fat.ent</span></tt> 为名保存在当前工作目录。 <tt class="docutils literal"><span class="pre">retrieve_pdb_file</span></tt> 方法有个可选参数 <tt class="docutils literal"><span class="pre">pdir</span></tt> 来指定路径保存所下载的PDB文件。</p>
<p><tt class="docutils literal"><span class="pre">retrieve_pdb_file</span></tt> 方法还有其他选项可以指定下载的压缩格式（默认的 <tt class="docutils literal"><span class="pre">.Z</span></tt> 格式和 <tt class="docutils literal"><span class="pre">gunzip</span></tt> 格式）。另外，在创建 <tt class="docutils literal"><span class="pre">PDBList</span></tt> 对象时还可以指定PDB ftp站点。一般使用Worldwide Protein Data Bank（ <tt class="docutils literal"><span class="pre">`ftp://ftp.wwpdb.org/pub/pdb/data/structures/divided/pdb/</span></tt> &lt;<a class="reference external" href="ftp://ftp.wwpdb.org/pub/pdb/data/structures/divided/pdb/">ftp://ftp.wwpdb.org/pub/pdb/data/structures/divided/pdb/</a>&gt;`__ ）。详细内容参见API文档。再次感谢Kristian Rother对此模块的所做的贡献。</p>
</div>
<div class="section" id="pdb-downloading-the-entire-pdb">
<h3>11.8.2  下载完整PDB数据 Downloading the entire PDB<a class="headerlink" href="#pdb-downloading-the-entire-pdb" title="Permalink to this headline">¶</a></h3>
<p>下面的命令将会保存所有PDB文件至 <tt class="docutils literal"><span class="pre">/data/pdb</span></tt> 路径：</p>
<blockquote>
<div><p>python PDBList.py all /data/pdb</p>
<p>python PDBList.py all /data/pdb -d</p>
</div></blockquote>
<p>在API中这个方法叫做 <tt class="docutils literal"><span class="pre">download_entire_pdb</span></tt> 。添加 <tt class="docutils literal"><span class="pre">-d</span></tt> 能保存所有文件在相同的路径。否则将分别保存至和它们PDB ID相对应的子目录中。根据网速，完整的下载全部PDB文件大概需要2-4天。</p>
</div>
<div class="section" id="pdn">
<h3>11.8.3  保持本地拷贝与PDN数据库更新<a class="headerlink" href="#pdn" title="Permalink to this headline">¶</a></h3>
<p>这也能通过 <tt class="docutils literal"><span class="pre">PDBList</span></tt> 对象来完成。可以简单的创建一个 <tt class="docutils literal"><span class="pre">PDBList</span></tt> 对象（指定本地拷贝保存的路径），然后调用 <tt class="docutils literal"><span class="pre">update_pdb</span></tt> 方法：
This can also be done using the <tt class="docutils literal"><span class="pre">PDBList</span></tt> object. One simply creates a
<tt class="docutils literal"><span class="pre">PDBList</span></tt> object (specifying the directory where the local copy of the
PDB is present) and calls the <tt class="docutils literal"><span class="pre">update_pdb</span></tt> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pl</span> <span class="o">=</span> <span class="n">PDBList</span><span class="p">(</span><span class="n">pdb</span><span class="o">=</span><span class="s">&#39;/data/pdb&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pl</span><span class="o">.</span><span class="n">update_pdb</span><span class="p">()</span>
</pre></div>
</div>
<p>当然还可以用 <tt class="docutils literal"><span class="pre">cronjob</span></tt> 实现本地拷贝每周的自动更新。可以指定PDB ftp站点（详见API文档）。</p>
<p><tt class="docutils literal"><span class="pre">PDBList</span></tt> 有其他许多另外的方法可供调用。 <tt class="docutils literal"><span class="pre">get_all_obsolete</span></tt> 方法可以获取已经废弃不用的PDB entries；  <tt class="docutils literal"><span class="pre">changed_this_week</span></tt>  方法可以获得当前一周内新增加、修改或废弃的PDB entries。更多 <tt class="docutils literal"><span class="pre">PDBList</span></tt> 的用法参见API文档。</p>
</div>
</div>
<div class="section" id="id32">
<h2>11.9  一般疑问<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h2>
<div class="section" id="bio-pdb">
<h3>11.9.1  对Bio.PDB测试如何？<a class="headerlink" href="#bio-pdb" title="Permalink to this headline">¶</a></h3>
<p>事实上，相当好。Bio.PDB已经在从PDB获得的近5500个结构上广泛的测试过，所有文件都能正常的被解析。更多细节可以参考在Bioinformatics上发表的关于Bio.PDB的文章。Bio.PDB已经并且正在被作为很使用的工具用于许多研究项目中。我几乎每天都在用它，处于研究目的、提升其性能和增加新属性。</p>
</div>
<div class="section" id="id33">
<h3>11.9.2  它有多快？<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">PDBParser</span></tt> 的性能经将近800个结构测试（每个都属于不同的SCOP超家族），总共花费20分钟左右，也就是说平均每个结构只需1.5秒。在一台1000 MHz的PC上解析巨大的包含近64000个原子的核糖体亚单位（1FKK）只需10秒。总而言之，它比其他的一些应用程序更快。</p>
</div>
<div class="section" id="id34">
<h3>11.9.3  是否支持分子图形展示？<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h3>
<p>现在已经有很多应用直接或间接用Pyhton解决问题的应用，将来也可能回用到Bio.PDB。我的选择是Pymol，我在Pymol中使用Bio.PDB非常成功，将来会有特定的Bio.PDB中会有特定的PyMol模块。基于Python的分子图形展示的解决方案包括：</p>
<ul class="simple">
<li>PyMol:
<tt class="docutils literal"><span class="pre">`http://pymol.sourceforge.net/</span></tt> &lt;<a class="reference external" href="http://pymol.sourceforge.net/">http://pymol.sourceforge.net/</a>&gt;`__</li>
<li>Chimera:
<tt class="docutils literal"><span class="pre">`http://www.cgl.ucsf.edu/chimera/</span></tt> &lt;<a class="reference external" href="http://www.cgl.ucsf.edu/chimera/">http://www.cgl.ucsf.edu/chimera/</a>&gt;`__</li>
<li>PMV:
<tt class="docutils literal"><span class="pre">`http://www.scripps.edu/~sanner/python/</span></tt> &lt;<a class="reference external" href="http://www.scripps.edu/~sanner/python/">http://www.scripps.edu/~sanner/python/</a>&gt;`__</li>
<li>Coot:
<tt class="docutils literal"><span class="pre">`http://www.ysbl.york.ac.uk/~emsley/coot/</span></tt> &lt;<a class="reference external" href="http://www.ysbl.york.ac.uk/~emsley/coot/">http://www.ysbl.york.ac.uk/~emsley/coot/</a>&gt;`__</li>
<li>CCP4mg:
<tt class="docutils literal"><span class="pre">`http://www.ysbl.york.ac.uk/~lizp/molgraphics.html</span></tt> &lt;<a class="reference external" href="http://www.ysbl.york.ac.uk/~lizp/molgraphics.html">http://www.ysbl.york.ac.uk/~lizp/molgraphics.html</a>&gt;`__</li>
<li>mmLib: <tt class="docutils literal"><span class="pre">`http://pymmlib.sourceforge.net/</span></tt> &lt;<a class="reference external" href="http://pymmlib.sourceforge.net/">http://pymmlib.sourceforge.net/</a>&gt;`__</li>
<li>VMD:
<tt class="docutils literal"><span class="pre">`http://www.ks.uiuc.edu/Research/vmd/</span></tt> &lt;<a class="reference external" href="http://www.ks.uiuc.edu/Research/vmd/">http://www.ks.uiuc.edu/Research/vmd/</a>&gt;`__</li>
<li>MMTK:
<tt class="docutils literal"><span class="pre">`http://starship.python.net/crew/hinsen/MMTK/</span></tt> &lt;<a class="reference external" href="http://starship.python.net/crew/hinsen/MMTK/">http://starship.python.net/crew/hinsen/MMTK/</a>&gt;`__</li>
</ul>
</div>
<div class="section" id="id35">
<h3>11.9.4  谁在用Bio.PDB？<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h3>
<p>Bio.PDB曾用于构建DISEMBL，一个能预测蛋白结构中的非规则区域( <tt class="docutils literal"><span class="pre">`http://dis.embl.de/</span></tt> &lt;<a class="reference external" href="http://dis.embl.de/">http://dis.embl.de/</a>&gt;`__ )；COLUMBA，一个提供经注释的蛋白结构的站点( <tt class="docutils literal"><span class="pre">`http://www.columba-db.de/</span></tt> &lt;<a class="reference external" href="http://www.columba-db.de/">http://www.columba-db.de/</a>&gt;`__ )。Bio.PDB也用于PDB数据库中蛋白质间大规模活性位点相似性的搜索[<a class="reference external" href="#hamelryck2003b">19</a>, Hamelryck, 2003]，开发新的算法鉴别线性二级结构元件[<a class="reference external" href="#majumdar2005">26</a>, Majumdar <em>et al.</em>, 2005]。</p>
<p>基于新属性和信息的需求反馈，也可以得知Bio.PDB也在许多大型制药公司中使用。</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Chapter 11  走向3D：PDB模块</a><ul>
<li><a class="reference internal" href="#id1">11.1  结构文件的读与写</a><ul>
<li><a class="reference internal" href="#pdb">11.1.1  PDB文件的读取</a></li>
<li><a class="reference internal" href="#mmcif">11.1.2  读取mmCIF文件</a></li>
<li><a class="reference internal" href="#pdb-xml">11.1.3  读取PDB XML格式的文件</a></li>
<li><a class="reference internal" href="#id2">11.1.4  写PDB文件</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id3">11.2  结构表示方法</a><ul>
<li><a class="reference internal" href="#id4">11.2.1  结构</a></li>
<li><a class="reference internal" href="#id5">11.2.2  结构域</a></li>
<li><a class="reference internal" href="#id6">11.2.3  链</a></li>
<li><a class="reference internal" href="#id7">11.2.4  残基</a></li>
<li><a class="reference internal" href="#atom">11.2.5  原子Atom</a></li>
<li><a class="reference internal" href="#atom-residue-chain-model">11.2.6  从结构分子中提取特定的 <tt class="docutils literal"><span class="pre">Atom/Residue/Chain/Model</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#disorder">11.3  Disorder</a><ul>
<li><a class="reference internal" href="#id8">11.3.1  一般途径</a></li>
<li><a class="reference internal" href="#id9">11.3.2  杂乱的原子</a></li>
<li><a class="reference internal" href="#id10">11.3.3  杂乱的残基</a><ul>
<li><a class="reference internal" href="#id11">普通例子</a></li>
<li><a class="reference internal" href="#id12">点突变</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#hetero">11.4  Hetero残基</a><ul>
<li><a class="reference internal" href="#id13">11.4.1  相关问题</a></li>
<li><a class="reference internal" href="#id14">11.4.2  水分子</a></li>
<li><a class="reference internal" href="#id15">11.4.3  其他hetero残基</a></li>
</ul>
</li>
<li><a class="reference internal" href="#structure">11.5  操纵Structure对象</a></li>
<li><a class="reference internal" href="#id16">11.6  结构分析</a><ul>
<li><a class="reference internal" href="#id17">11.6.1  测定距离</a></li>
<li><a class="reference internal" href="#id18">11.6.2  测定角度</a></li>
<li><a class="reference internal" href="#measuring-torsion-angles">11.6.3  测定扭转角Measuring torsion angles</a></li>
<li><a class="reference internal" href="#determining-atom-atom-contacts">11.6.4  确定原子-原子接触Determining atom-atom contacts</a></li>
<li><a class="reference internal" href="#id19">11.6.5  叠加两个结构</a></li>
<li><a class="reference internal" href="#id20">11.6.6  相互映射这两个结构的残基到对方</a></li>
<li><a class="reference internal" href="#half-sphere-exposure">11.6.7  计算Half Sphere Exposure</a></li>
<li><a class="reference internal" href="#id21">11.6.8  确定二级结构</a></li>
<li><a class="reference internal" href="#id22">11.6.9  计算残基深度</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id23">11.7  PDB文件中的常见问题</a><ul>
<li><a class="reference internal" href="#id24">11.7.1  例子</a><ul>
<li><a class="reference internal" href="#id25">11.7.1.1  重复残基</a></li>
<li><a class="reference internal" href="#id26">11.7.1.2  重复原子</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id27">11.7.2  自动修正</a><ul>
<li><a class="reference internal" href="#altloc">11.7.2.1  无序原子的空altloc</a></li>
<li><a class="reference internal" href="#id28">11.7.2.2  断链</a></li>
</ul>
</li>
<li><a class="reference internal" href="#fatal-errors">11.7.3  致命错误Fatal errors</a><ul>
<li><a class="reference internal" href="#id29">11.7.3.1  残基重复</a></li>
<li><a class="reference internal" href="#id30">11.7.3.2  原子重复</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#protein-data-bank">11.8  访问Protein Data Bank</a><ul>
<li><a class="reference internal" href="#id31">11.8.1  从Protein Data Bank下载结构</a></li>
<li><a class="reference internal" href="#pdb-downloading-the-entire-pdb">11.8.2  下载完整PDB数据 Downloading the entire PDB</a></li>
<li><a class="reference internal" href="#pdn">11.8.3  保持本地拷贝与PDN数据库更新</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id32">11.9  一般疑问</a><ul>
<li><a class="reference internal" href="#bio-pdb">11.9.1  对Bio.PDB测试如何？</a></li>
<li><a class="reference internal" href="#id33">11.9.2  它有多快？</a></li>
<li><a class="reference internal" href="#id34">11.9.3  是否支持分子图形展示？</a></li>
<li><a class="reference internal" href="#id35">11.9.4  谁在用Bio.PDB？</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/chapter11_chn.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="index.html">python_chn_ch11 .1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, joey.zhong.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>